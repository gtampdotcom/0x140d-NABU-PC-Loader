; Interrupt handler routines and VDP and Keyboard IRQs
;
; Copyright (c) 2024 Brian Johnson.  All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set irq_vector_base, 0xF000                ; Base address of the interrupt vector table
;.set KEYBOARD_DATA, 0x90                    ; Keyboard data port
;.set KEYBOARD_STATUS, 0x91                  ; Keyboard status port
.set AY38910_DATA, 0x40                     ; Data port of AY-3-8910
.set AY38910_ADDR, 0x41                     ; Address latch of AY-3-8910
.set IO_PORT_A, 0x0E                        ; Register for Port A on the AY-3-8910

; Interrupt bit masks
.set INTERRUPT_HCCA_RX, 0x80                ; Bit 7: HCCA RX interrupt
.set INTERRUPT_HCCA_TX, 0x40                ; Bit 6: HCCA TX interrupt
;.set INTERRUPT_KEYBOARD, 0x20               ; Bit 5: Keyboard interrupt
.set INTERRUPT_VDP, 0x10                    ; Bit 4: VDP interrupt
;.set INTERRUPT_OPTION_CARD_0, 0x08          ; Bit 3: Option Card 0 interrupt
;.set INTERRUPT_OPTION_CARD_1, 0x04          ; Bit 2: Option Card 1 interrupt
;.set INTERRUPT_OPTION_CARD_2, 0x02          ; Bit 1: Option Card 2 interrupt
;.set INTERRUPT_OPTION_CARD_3, 0x01          ; Bit 0: Option Card 3 interrupt

.section .text, "acrx"

; Keyboard interrupt handler
; .global keyboard_interrupt
; keyboard_interrupt:
    ; push af                                 ; Save registers
    ; push bc
    ; push de
    ; push hl
    ; ld d, 0                                 ; Zero D for table lookups
    ; in  a, (KEYBOARD_DATA)                  ; Read keyboard scan code
    ;cp 0x94                                 ; Check for watchdog signal
    ;jp z, keyboard_interrupt_exit
	
	;cp 0x2d                                 ; Check for '-' key (mapped to '*')
    ;jr z, handle_keypad_star
    ;cp 0x3d                                 ; Check for '=' key (mapped to '#')
    ;jr z, handle_keypad_pound
    ;cp 0xe0                                 ; Check if scan code >= 0xe0
    ;jr nc, handle_stick_emulation
    ;cp 0xc0                                 ; Check if scan code >= 0xc0
    ;jr nc, keyboard_interrupt_exit
    ;cp 0xa0                                 ; Check if scan code >= 0xa0
    ;jp nc, handle_joystick
    ;cp 0x3a                                 ; Check if scan code >= 0x3a
    ;jr nc, keyboard_interrupt_exit
    ;cp 0x30                                 ; Check if scan code >= 0x30
    ;jr nc, handle_keypad_number
; keyboard_interrupt_exit:
    ; pop hl                                  ; Restore registers
    ; pop de
    ; pop bc
    ; pop af
    ; ei                                      ; Re-enable interrupts
    ; ret                                     ; Return from interrupt


; VDP VSYNC interrupt handler
.global vdp_vsync_interrupt
vdp_vsync_interrupt:
    push af                                 ; Save AF
    call 0x66                               ; Call NMI interrupt vector
    in a, (0xA1)                            ; Clear VDP interrupt
    pop af                                  ; Restore AF
    ei                                      ; Re-enable interrupts
    ret                                     ; Return from interrupt

; Null IRQ stub function
.global nullirq
nullirq:
    ei                                      ; Re-enable interrupts
    ret                                     ; Return from interrupt

; Install interrupt handlers
; Input: None
.global install_interrupt_handlers
install_interrupt_handlers:
    ld hl, irq_vector_base                  ; Start of the interrupt vector table
    ld de, nullirq                          ; Address of nullirq function
    ld b, 0x80                              ; Number of interrupt vector entries
install_loop:
    ld (hl), e                              ; Write low byte of nullirq address
    inc hl                                  ; Increment to next byte
    ld (hl), d                              ; Write high byte of nullirq address
    inc hl                                  ; Increment to next entry
    djnz install_loop                       ; Continue until all entries are filled

    ; Install specific handlers
    ; ld hl, irq_vector_base + 4              ; Entry 2 (offset 4)
    ; ld de, keyboard_interrupt               ; Address of keyboard_interrupt
    ; ld (hl), e                              ; Write low byte
    ; inc hl
    ; ld (hl), d                              ; Write high byte

    ld hl, irq_vector_base + 6              ; Entry 3 (offset 6)
    ld de, vdp_vsync_interrupt              ; Address of vdp_vsync_interrupt
    ld (hl), e                              ; Write low byte
    inc hl
    ld (hl), d                              ; Write high byte

    ; Set the interrupt vector base address
    ld a, irq_vector_base >> 8              ; Load high byte of the vector base address
    ld i, a                                 ; Store it in the I register

    ; Enable VDP and keyboard interrupts
    ld a, INTERRUPT_VDP ;| INTERRUPT_KEYBOARD
    call set_interrupts

    ; Set Z80 interrupt mode to IM 2
    im 2                                    ; Enable Interrupt Mode 2

    ret                                     ; Return after setting up the table

; Enable specific interrupts
; Input: A = Bitmask of interrupts to enable
.global enable_interrupts
enable_interrupts:
    ld hl, current_interrupt_mask           ; Address of the interrupt mask state
    ld b, (hl)                              ; Load current interrupt mask
    or b                                    ; Enable specified interrupts in the mask
    ld (hl), a                              ; Save updated mask
    push af                                 ; Save A register (input bitmask)
    ld a, IO_PORT_A                         ; Load address of Port A into A
    out (AY38910_ADDR), a                   ; Select IO Port A register
    pop af                                  ; Restore A register (input bitmask)
    out (AY38910_DATA), a                   ; Write updated interrupt mask to Port A
    ret                                     ; Return after enabling interrupts

; Disable specific interrupts
; Input: A = Bitmask of interrupts to disable
.global disable_interrupts
disable_interrupts:
    ld hl, current_interrupt_mask           ; Address of the interrupt mask state
    ld b, (hl)                              ; Load current interrupt mask
    cpl                                     ; Invert the bitmask
    and b                                   ; Disable specified interrupts in the mask
    ld (hl), a                              ; Save updated mask
    push af                                 ; Save A register (input bitmask)
    ld a, IO_PORT_A                         ; Load address of Port A into A
    out (AY38910_ADDR), a                   ; Select IO Port A register
    pop af                                  ; Restore A register (input bitmask)
    out (AY38910_DATA), a                   ; Write updated mask to Port A
    ret                                     ; Return after disabling interrupts

; Set specific interrupts
; Input: A = Bitmask of interrupts to set
.global set_interrupts
set_interrupts:
    ld hl, current_interrupt_mask           ; Address of the interrupt mask state
    ld (hl), a                              ; Overwrite current interrupt mask
    push af                                 ; Save A register (input bitmask)
    ld a, IO_PORT_A                         ; Load address of Port A into A
    out (AY38910_ADDR), a                   ; Select IO Port A register
    pop af                                  ; Restore A register (input bitmask)
    out (AY38910_DATA), a                   ; Write new interrupt mask to Port A
    ret                                     ; Return after setting interrupts

.section .data, "adrw"

current_interrupt_mask: .byte 0x00          ; Local state variable for the interrupt mask
; status_led_state: .byte 0x03                ; State of control register (used front panel LED control)

; joystick_bitmask:                           ; Table with bitmasks used to set or clear joystick bits
    ; .byte 0xFD, 0xF7, 0xFE, 0xFB, 0x00, 0xBF

; joy_table:                                  ; Table to convert NABU joystick to coleco joystick
    ; .byte 0x80, 0x88, 0x84, 0x8C
    ; .byte 0x82, 0x8A, 0x86, 0x8E
    ; .byte 0x81, 0x89, 0x85, 0x8D
    ; .byte 0x83, 0x8B, 0x87, 0x8F

; keypad_table:                               ; Table for converting NABU keyboard to coleco keypad
    ; .byte 0x0A, 0x0D, 0x07, 0x0C, 0x02
    ; .byte 0x03, 0x0E, 0x05, 0x01, 0x0B

; current_keypad: .byte 0x00                  ; Byte that controls which controller is active

; .global keypad1_value
; keypad1_value: .byte 0x7F                   ; Value of keypad 1
; keypad2_value: .byte 0x7F                   ; Value of keypad 2

; .global joy1_value
; joy1_value: .byte 0x7F                      ; Value of joystick 1
; joy2_value: .byte 0x7F                      ; Value of joystick 2

